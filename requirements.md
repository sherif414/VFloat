# **Requirements Sheet for a Vue 3 Port of Floating UI React**

**1\. Introduction to the Vue 3 Port of Floating UI**

Floating UI stands as a pivotal library in modern web development, offering a comprehensive solution for crafting sophisticated "floating" user interface elements such as tooltips, popovers, and dropdown menus 1. Its design addresses the inherent complexities of positioning these elements accurately relative to a designated trigger or "reference" element, all while ensuring they remain within the visible viewport and are fully accessible to users 1. The library's capabilities are built around two fundamental aspects: robust positioning and adaptable interaction management 1.

The positioning features of Floating UI provide developers with a powerful toolkit to anchor absolutely-positioned floating elements precisely next to their corresponding reference elements 1. This includes the intelligent handling of dynamic scenarios where the page is scrolled or resized, guaranteeing that the floating element maintains its connection to the trigger element 1. Furthermore, it incorporates mechanisms to proactively prevent floating elements from overlapping the edges of the viewport, a common challenge encountered with absolute positioning 1.

Beyond positioning, Floating UI offers a set of tools dedicated to managing the diverse and often intricate interactions associated with floating elements 1. The way a tooltip appears and disappears (e.g., upon hovering or focusing) differs significantly from the behavior of a combobox (e.g., opening on focus and allowing selection via typing), yet both share the characteristic of being floating and anchored to a trigger 1. The React package of Floating UI provides a collection of primitive Hooks and components that enable developers to construct reusable floating components with a wide range of complex and accessible interaction patterns 1.

Floating UI's architecture emphasizes modularity, ensuring that only the specific code necessary for the implemented features is included in the final application bundle 1. This "tree-shaking" capability is crucial for optimizing application performance and minimizing the library's footprint 1. The library is also engineered for flexibility and extensibility, allowing its use across various JavaScript frameworks, including React, Vue, and even vanilla JavaScript, as well as on platforms like React Native 1. Developers can customize the library's behavior to align with their unique application requirements without being limited by predefined defaults 1. The React package, @floating-ui/react, provides a rich set of foundational Hooks and components that empower developers to build highly interactive and accessible floating UI components 1.

The primary objective of this endeavor is to create a fully featured Vue 3 port of the @floating-ui/react library. This necessitates the development of direct and equivalent counterparts for every feature, Hook, and component currently available in the React version. The goal is to provide a Vue 3 API that mirrors the React API as closely as possible, facilitating a smoother transition for developers familiar with floating-ui/react and allowing them to leverage their existing knowledge. Furthermore, the Vue 3 port should maintain the same high degree of flexibility and customizability offered by the React version. Developers should retain the ability to configure the behavior of floating elements through options and props, enabling them to adapt the library to the specific needs of their Vue 3 applications.

A fundamental requirement for the Vue 3 port is that it must be built upon the foundation of the @floating-ui/dom library 1. This framework-agnostic library serves as the core positioning engine for Floating UI 1. @floating-ui/dom exposes the essential computePosition function, which is responsible for calculating the optimal x and y coordinates for the floating element relative to its reference element 1. It also includes a suite of powerful middleware functions that can be used to modify the positioning based on various constraints and desired behaviors, such as preventing overflow, adding offsets, and positioning arrows 1. While the React version utilizes React's refs for interacting with DOM elements during positioning calculations within @floating-ui/dom, the Vue 3 port will need to leverage Vue's ref system to achieve the same level of DOM interaction. The requirements outlined in this document will specify how Vue refs should be employed to provide the necessary DOM element references to the underlying @floating-ui/dom functions, ensuring seamless integration and accurate positioning.

**2\. Core Positioning Requirements (Leveraging @floating-ui/dom)**

The cornerstone of the positioning logic within the Vue 3 port will be the direct utilization of the computePosition function provided by the @floating-ui/dom library 1. This function will be invoked internally within the primary positioning composable to execute the fundamental calculations required to determine the floating element's position relative to its reference 1. The computePosition function expects two primary arguments: a reference DOM element and a floating DOM element 4. In the Vue 3 port, these elements will be accessed through Vue refs that are either passed in as options to the composable or obtained by the user within their Vue component 4. Upon successful computation, computePosition returns a Promise that resolves to an object containing the calculated x and y coordinates for the floating element, along with other pertinent positioning data, including the final placement of the element and any middlewareData generated by applied middleware 4. Given the asynchronous nature of the computePosition function (it returns a Promise), the Vue 3 port will need to handle this operation effectively within its composables 4. This will likely involve employing async/await syntax to manage the resolution of the Promise and subsequently update the reactive state variables (such as x, y, and floatingStyles) that will be exposed to the user of the composable. Additionally, appropriate error handling mechanisms should be considered to manage potential issues during the Promise resolution process.

The Vue 3 port must provide full support for all twelve placement options defined within Floating UI 4. These options dictate the initial position of the floating element in relation to its reference element and include: 'top', 'top-start', 'top-end', 'right', 'right-start', 'right-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', and 'left-end' 4. The suffixes '-start' and '-end' in these placement options refer to the alignment of the floating element along the edge of the reference element that corresponds to the specified placement 5. It is essential that these alignments are implemented as "logical" properties, meaning they should automatically adapt to the writing direction of the text content (e.g., from left to right or right to left) 5.

The port should also support both 'absolute' and 'fixed' positioning strategies, which determine how the floating element is positioned within the document flow 5. The 'absolute' strategy positions the floating element relative to its nearest positioned ancestor in the DOM tree 5. This is generally the default strategy and often requires less computational overhead for the browser when updating the position 5. In contrast, the 'fixed' strategy positions the floating element relative to the viewport 5. This strategy is particularly beneficial when the reference element is also fixed within the viewport, as it can prevent visual "jumps" or inconsistencies during scrolling 5. Additionally, using the 'fixed' strategy can sometimes allow the floating element to break free from clipping contexts imposed by ancestor elements in the DOM 5.

To ensure that floating elements remain consistently anchored to their reference elements even when users scroll the page or resize the browser window, the Vue 3 port will need to provide a mechanism that mirrors the functionality of React's autoUpdate utility 3. This functionality will likely involve utilizing Vue's lifecycle hooks, specifically onMounted to establish event listeners for scroll and resize events on the appropriate window or scrollable ancestor elements, and onUnmounted to remove these listeners when the associated component is destroyed 3. When these events are triggered, the function responsible for updating the floating element's position (which internally calls computePosition) should be invoked 3. Furthermore, the whileElementsMounted option available in React's useFloating, which simplifies the integration of autoUpdate, should have a corresponding implementation in the Vue port 3. This could be implemented as a specific option within the primary positioning composable that accepts a callback function (similar to autoUpdate) to manage the continuous updating of the floating element's position as long as both the reference and floating elements are mounted in the DOM 3. It is important to note that the React documentation advises against using the whileElementsMounted option when the floating element is merely hidden using CSS (e.g., via display: none) and instead recommends using a useEffect Hook in such cases 3. The Vue port's documentation should provide similar guidance, clearly explaining the optimal approach for handling autoUpdate in different scenarios (conditional rendering versus CSS visibility control), potentially recommending the use of Vue's onMounted and onUnmounted hooks with a custom update function for cases where the floating element's visibility is controlled solely through CSS. This distinction arises because autoUpdate relies on observing changes to the dimensions and position of the elements, and elements hidden with CSS might not trigger the necessary recalculations. Therefore, clear documentation is crucial to ensure accurate and performant updates across various usage patterns in the Vue port.

**3\. Requirements for Porting @floating-ui/react Features**

The Vue 3 port will necessitate the creation of a primary composable, conceptually equivalent to React's useFloating() 3. This composable will serve as the central hub for managing all aspects of the floating element's positioning state and associated logic 3. Its responsibilities will include obtaining the Vue refs to the reference and floating DOM elements, which will likely be provided as options or accessed by the user within their Vue component 3. The composable will then utilize these refs to invoke the computePosition function from @floating-ui/dom and manage the resulting Promise, ensuring that the positioning calculations are performed correctly 3. The composable should return a set of reactive state variables that provide all the necessary information for positioning the floating element effectively 3. This includes reactive x and y coordinates representing the calculated position, a reactive placement string indicating the final placement after middleware processing, a reactive strategy string reflecting the positioning strategy in use ('absolute' or 'fixed'), and a reactive floatingStyles object containing the CSS properties (e.g., top, left, or transform) that should be applied to the floating element's style attribute to achieve the desired positioning 3.

The Vue 3 port will need to establish the concept of an "open" state, likely using Vue's ref or reactive to hold a boolean value that determines the visibility of the floating element 3. Additionally, a mechanism for an onOpenChange callback, mirroring the functionality in React, should be provided 3. This callback function will be invoked whenever the open state needs to be modified, allowing the user of the composable to update their application's state accordingly. The callback should ideally receive the new open state value as an argument 3. To manage the open state based on user interactions, such as hover, focus, and click, the Vue 3 port will require the implementation of a set of interaction composables, which will be detailed in section 4 3. These composables will handle the necessary event listeners and logic to update the open state in response to user actions 3.

The Vue 3 port must implement equivalent versions of all the middleware available in @floating-ui/react 3. These middleware functions are essential for fine-tuning the positioning of the floating element and ensuring it behaves as expected in various scenarios 3. Each middleware should be implemented as a separate Vue 3 composable or a utility function that can be passed as an element within an array to the main positioning composable 3. The offset middleware will be responsible for adding a specified distance or margin between the reference and floating elements 3. The shift middleware will adjust the position of the floating element along the specified axis (or axes) to ensure it remains within the boundaries of a clipping container 3. The flip middleware will detect if the floating element would overflow and automatically attempt to flip it to the opposite side 3. The arrow middleware will provide data to position an inner "arrow" element 3. The size middleware will allow for adjusting the size of the floating element 3. The autoPlacement middleware will automatically determine the most suitable placement based on available space 3. The hide middleware will provide data to conditionally hide the floating element when it's clipped 3. Finally, the inline middleware will improve positioning precision for inline reference elements 3. The order in which these middleware are applied is often significant, and the Vue port should respect the order defined by the user 7. When using reactive Vue state within the options of these middleware, the Vue port needs to ensure that these dependencies are properly tracked and that the middleware are re-executed when the reactive values change 7. This might involve using Vue's watch or computed properties internally within the middleware implementations to maintain reactivity.

The Vue 3 port should also provide a function, potentially named detectOverflow, that mirrors the functionality of its React counterpart 3. This function will enable developers to programmatically determine if a given floating element is overflowing any of its clipping boundaries 3. Furthermore, support for virtual reference elements should be implemented 3. This will allow developers to position a floating element relative to an arbitrary point or object instead of being restricted to real DOM elements 3. This will likely involve allowing users to pass an object (instead of a DOM element ref) as the reference in the main positioning composable, with this object conforming to the expected interface, typically including properties like getBoundingClientRect and contextElement 3.

**4\. Detailed Requirements for Vue 3 Composables (Porting React Hooks)**

* **4.1 useFloating() Equivalent:** The primary positioning composable in the Vue 3 port should be named useFloating and should accept an optional options object as its argument 7. The options object should support the following properties: placement (string, default 'bottom'), strategy (string, default 'absolute'), transform (boolean, default true), middleware (array of middleware functions, default \`\`), elements (object with reference and floating properties accepting Vue ref or DOM element), whileElementsMounted (function for autoUpdate integration), open (boolean ref, default false), and onOpenChange (callback function for open state changes) 7. The composable should return an object containing: reactive x and y coordinates, reactive placement and strategy strings, a reactive middlewareData object, a reactive isPositioned boolean, an update() function, a reactive floatingStyles object, a refs object with reference and floating Vue ref objects, and an elements object containing the current DOM elements 7. The documentation must clearly illustrate the correct usage of Vue refs with the elements option 7.  
* **4.2 Interaction Composables:**  
  * **useHover():** Accepts the context object and returns event handler props for the reference element. Should have enabled (default true), move (consider implementation), and delay (number or object, integrates with \<FloatingDelayGroup\>) options 3.  
  * **useFocus():** Accepts the context object and returns event handler props for the reference element. Should have enabled (default true) and visibleOnly (default false) options 3.  
  * **useClick():** Accepts the context object and returns an event handler prop for the reference element. Should have an enabled option (default true) 3.  
  * **useDismiss():** Accepts the context object and returns event handler props for both reference and floating elements. Should support enabled (default true), escapeKey (default true), referencePress (default false), outsidePress (default true), ancestorScroll (default false), bubbles (default undefined), capture (default true), referencePressEvent (default 'pointerdown'), and outsidePressEvent (default 'pointerdown') options 3.  
  * **useListNavigation():** Accepts context and options (listRef, activeIndex, onNavigate, enabled, selectedIndex, loop, nested, rtl, virtual, virtualItemRef, allowEscape, orientation, cols, focusItemOnOpen, focusItemOnHover, openOnArrowKeyDown, disabledIndices, scrollItemIntoView, itemSizes, dense). Returns event handler props, ARIA attributes, and getItemProps 3.  
  * **useTypeahead():** Accepts context and options (listRef, activeIndex, onMatch, enabled, findMatch, resetMs, ignoreKeys, selectedIndex, onTypingChange). Returns event handler props 3.  
  * **useTransition():** Implement as useTransitionStyles (accepts context and options, returns isMounted and styles) and useTransitionStatus (accepts context and options, returns status) 3.  
  * **useClientPoint():** Accepts context and options (enabled, axis, x, y). Returns event handler props 3.  
  * **useMergeRefs():** Accepts an array of Vue refs and returns a single merged ref 3.  
  * **useRole():** Accepts context and returns ARIA attribute props for reference and floating elements. Should handle different roles and provide getItemProps 3.  
  * **useInteractions():** Accepts an array of interaction composable return values and returns getReferenceProps, getFloatingProps, and getItemProps functions 3. Documentation must emphasize the importance of using these prop getters 3.  
* **4.3 Accessibility Considerations:** Ensure all composables and components facilitate accessible floating UI elements, including proper ARIA attributes via useRole and keyboard navigation via useListNavigation. Documentation should emphasize semantic HTML and ARIA roles 3.

**5\. Detailed Requirements for Vue 3 Components (Porting React Components)**

* **5.1 \<FloatingArrow\>:** A functional Vue 3 component rendering an SVG arrow. Props: context (required), width (default 14), height (default 7), tipRadius (default 0), fill (default "black"), stroke (default "none"), strokeWidth (default 0), staticOffset (optional) 3. Should use arrow middleware data for positioning. Documentation should guide on styling 9.  
* **5.2 \<FloatingFocusManager\>:** A Vue 3 component for managing focus. Props: context (required), disabled (default false), initialFocus (default 0), returnFocus (default true), modal (default true), order (default \['content'\]), visuallyHiddenDismiss (default false) 11. Should handle modal and non-modal focus, work with \<FloatingPortal\>, and consider useListNavigation 11.  
* **5.3 \<FloatingPortal\>:** A Vue 3 component to render content in a different DOM location using Teleport. Props: root (optional, default document.body), id (optional), preserveTabOrder (default true) 22. Should have a corresponding useFloatingPortalNode() composable 22.  
* **5.4 \<FloatingTree\>:** A Vue 3 component providing context for nested floating elements using Vue Context. Should have corresponding composables: useFloatingNodeId(), useFloatingParentNodeId(), and useFloatingTree() 3.  
* **5.5 \<FloatingOverlay\>:** A Vue 3 component for a fixed overlay. Prop: lockScroll (default false) 3. Renders a \<div\> with necessary styles.  
* **5.6 \<FloatingList\> and \<useListItem\>:** \<FloatingList\> is a context provider. Props: elementsRef (required), labelsRef (optional) 3. useListItem registers an item. Returns ref and index. Accepts optional label 26.  
* **5.7 \<FloatingDelayGroup\> and \<useDelayGroup\>:** \<FloatingDelayGroup\> provides context for shared delay. Props: delay (required), timeoutMs (optional) 3. useDelayGroup accesses the context. Returns delay, isInstantPhase, currentId 10.  
* **5.8 \<Composite\> and \<CompositeItem\>:** \<Composite\> creates a single tab stop navigable list. Props: render, orientation (default 'horizontal'), loop (default true), rtl, cols (default 1), disabledIndices, activeIndex, onNavigate, itemSizes, dense 3. \<CompositeItem\> is an item within \<Composite\>. Prop: render 27.

**6\. Conclusion**

This document outlines the detailed requirements for creating a Vue 3 port of the floating-ui/react library. By adhering to these specifications, the resulting port will offer feature parity with the React version, leveraging the capabilities of Vue 3 and the core positioning logic of @floating-ui/dom. The successful implementation will empower Vue developers to build sophisticated and accessible floating UI elements within their applications. Thorough testing and a strong emphasis on accessibility best practices throughout the development process will be crucial to ensure the quality and usability of the Vue 3 port.

**Key Tables for the Report:**

* **Table 1: Mapping of React Hooks to Vue 3 Composables (Section 4\)**

| React Hook Name | Vue 3 Composable Name | Description |
| :---- | :---- | :---- |
| useFloating() | useFloating() | Core hook for positioning floating elements. |
| useHover() | useHover() | Enables showing the floating element on hover. |
| useFocus() | useFocus() | Enables showing the floating element on focus. |
| useClick() | useClick() | Enables showing the floating element on click. |
| useDismiss() | useDismiss() | Provides functionality to dismiss the floating element. |
| useListNavigation() | useListNavigation() | Helps with navigating through list-like floating elements using keyboard arrows. |
| useTypeahead() | useTypeahead() | Enables typeahead functionality within the floating element. |
| useTransition() | useTransitionStyles / useTransitionStatus | Facilitates adding transitions to the floating element's visibility. |
| useClientPoint() | useClientPoint() | Positions the floating element at a given client point. |
| useMergeRefs() | useMergeRefs() | A utility hook to merge multiple refs. |
| useRole() | useRole() | Sets the appropriate ARIA role for accessibility. |
| useInteractions() | useInteractions() | A hook that combines multiple interaction composables. |

* **Table 2: Mapping of React Components to Vue 3 Components (Section 5\)**

| React Component Name | Vue 3 Component Name | Description |
| :---- | :---- | :---- |
| FloatingArrow | \<FloatingArrow\> | A component for creating an arrow that points from the floating element to the reference element. |
| FloatingFocusManager | \<FloatingFocusManager\> | Manages focus within the floating element. |
| FloatingPortal | \<FloatingPortal\> | Renders the floating element in a different part of the DOM tree. |
| FloatingTree | \<FloatingTree\> | Helps manage nested floating elements. |
| FloatingOverlay | \<FloatingOverlay\> | A component for creating an overlay behind the floating element. |
| FloatingList | \<FloatingList\> | A component for list-like floating elements. |
| FloatingDelayGroup | \<FloatingDelayGroup\> | Allows for adding delays to the opening and closing of floating elements. |
| Composite | \<Composite\> | A component for creating composite floating elements. |
| CompositeItem | \<CompositeItem\> | An item within the \<Composite\> component. |

* **Table 3: Mapping of React Middleware to Vue 3 Implementation (Section 3.3)**

| React Middleware Name | Vue 3 Implementation | Description |
| :---- | :---- | :---- |
| offset | Composable/Utility | Adds distance or margin between the reference and floating elements. |
| shift | Composable/Utility | Prevents the floating element from overflowing a clipping container by shifting it to stay in view. |
| flip | Composable/Utility | Prevents the floating element from overflowing a clipping container by flipping it to the opposite placement. |
| arrow | Composable/Utility | Provides data to position an inner arrow element. |
| size | Composable/Utility | Resizes the floating element to fit within constraints or match the reference width. |
| autoPlacement | Composable/Utility | Automatically chooses the best placement based on available space. |
| hide | Composable/Utility | Provides data to hide the element when it's no longer attached to the reference due to clipping. |
| inline | Composable/Utility | Positions relative to individual client rects for better precision with inline elements. |

#### **Works cited**

1\. Getting Started | Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/getting-started](https://floating-ui.com/docs/getting-started)  
2\. floating-ui/README.md at master \- GitHub, accessed March 18, 2025, [https://github.com/floating-ui/floating-ui/blob/master/README.md](https://github.com/floating-ui/floating-ui/blob/master/README.md)  
3\. React | Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/react](https://floating-ui.com/docs/react)  
4\. Tutorial | Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/tutorial](https://floating-ui.com/docs/tutorial)  
5\. computePosition \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/computeposition](https://floating-ui.com/docs/computeposition)  
6\. Getting started with Floating UI \- DEV Community, accessed March 18, 2025, [https://dev.to/logrocket/getting-started-with-floating-ui-250a](https://dev.to/logrocket/getting-started-with-floating-ui-250a)  
7\. useFloating | Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/usefloating](https://floating-ui.com/docs/usefloating)  
8\. Middleware | Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/middleware](https://floating-ui.com/docs/middleware)  
9\. FloatingArrow \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/floatingarrow](https://floating-ui.com/docs/floatingarrow)  
10\. FloatingDelayGroup | Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/floatingdelaygroup](https://floating-ui.com/docs/floatingdelaygroup)  
11\. useFocus \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/usefocus](https://floating-ui.com/docs/usefocus)  
12\. useDismiss | Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/usedismiss](https://floating-ui.com/docs/usedismiss)  
13\. useListNavigation \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/uselistnavigation](https://floating-ui.com/docs/uselistnavigation)  
14\. useTypeahead \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/usetypeahead](https://floating-ui.com/docs/usetypeahead)  
15\. useTransition \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/usetransition](https://floating-ui.com/docs/usetransition)  
16\. useClientPoint \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/useclientpoint](https://floating-ui.com/docs/useclientpoint)  
17\. React Utils \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/react-utils](https://floating-ui.com/docs/react-utils)  
18\. useRole | Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/userole](https://floating-ui.com/docs/userole)  
19\. useInteractions \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/useinteractions](https://floating-ui.com/docs/useinteractions)  
20\. FloatingFocusManager \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/floatingfocusmanager](https://floating-ui.com/docs/floatingfocusmanager)  
21\. Popover \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/popover](https://floating-ui.com/docs/popover)  
22\. FloatingPortal | Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/floatingportal](https://floating-ui.com/docs/floatingportal)  
23\. FloatingTree | Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/floatingtree](https://floating-ui.com/docs/floatingtree)  
24\. React Examples \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/react-examples](https://floating-ui.com/docs/react-examples)  
25\. FloatingOverlay | Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/floatingoverlay](https://floating-ui.com/docs/floatingoverlay)  
26\. FloatingList | Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/floatinglist](https://floating-ui.com/docs/floatinglist)  
27\. Composite \- Floating UI, accessed March 18, 2025, [https://floating-ui.com/docs/composite](https://floating-ui.com/docs/composite)